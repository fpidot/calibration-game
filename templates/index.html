<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wikipedia Calibration Game</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script> <!-- If using time scale, otherwise remove -->
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: auto; }
        #question-container { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9; }
        #options-container ul { list-style: none; padding: 0; }
        #options-container li { margin-bottom: 10px; }
        .option-button { display: block; width: 100%; padding: 10px; text-align: left; background-color: #eee; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
        .option-button:hover { background-color: #ddd; }
        .option-button.selected { background-color: #add8e6; border-color: #87ceeb; }
        .option-button.correct { background-color: #90ee90; border-color: #3cb371; }
        .option-button.incorrect { background-color: #f08080; border-color: #cd5c5c; }
        #confidence-section { margin-top: 20px; }
        #result { margin-top: 15px; padding: 10px; border-radius: 4px; }
        #result.correct { background-color: #dff0d8; border: 1px solid #d6e9c6; color: #3c763d; }
        #result.incorrect { background-color: #f2dede; border: 1px solid #ebccd1; color: #a94442; }
        #stats-container { margin-top: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #fafafa; }
        #calibration-chart-container { margin-top: 20px; max-width: 600px; } /* Limit chart width */
        #loading { display: none; font-style: italic; color: #555; }
        #error-message { color: red; margin-top: 10px; font-weight: bold; }
        .wiki-link { font-size: 0.9em; color: #555; margin-left: 5px; }
    </style>
</head>
<body>

    <h1>Wikipedia Calibration Game</h1>

    <div id="game-area">
        <button id="new-question-button">Get New Question</button>
        <div id="loading">Loading question...</div>

        <div id="question-container" style="display: none;">
            <p id="question-text"></p>
            <a id="wiki-link" href="#" target="_blank" class="wiki-link" style="display: none;"></a>
            <div id="options-container">
                <ul></ul>
            </div>
            <div id="confidence-section">
                <label for="confidence">Confidence (0-100%): </label>
                <input type="range" id="confidence" name="confidence" min="0" max="100" value="50">
                <span id="confidence-value">50%</span>
            </div>
            <button id="submit-answer-button" disabled>Submit Answer</button>
            <div id="result"></div>
        </div>
        <div id="error-message"></div>
    </div>

    <div id="stats-container">
        <h2>Session Statistics</h2>
        <p>Questions Answered: <span id="stat-answered">0</span></p>
        <p>Correct Answers: <span id="stat-correct">0</span> (<span id="stat-accuracy">N/A</span>%)</p>
        <p>Average Brier Score: <span id="stat-avg-brier">N/A</span></p>
        <div id="calibration-chart-container">
            <canvas id="calibrationChart"></canvas>
        </div>
    </div>

    <script>
        // DOM Elements
        const newQuestionButton = document.getElementById('new-question-button');
        const loadingElement = document.getElementById('loading');
        const questionContainer = document.getElementById('question-container');
        const questionTextElement = document.getElementById('question-text');
        const wikiLinkElement = document.getElementById('wiki-link');
        const optionsElement = document.getElementById('options-container').querySelector('ul');
        const confidenceSlider = document.getElementById('confidence');
        const confidenceValueElement = document.getElementById('confidence-value');
        const submitButton = document.getElementById('submit-answer-button');
        const resultElement = document.getElementById('result');
        const errorMessageElement = document.getElementById('error-message');
        // Stats Elements
        const statAnswered = document.getElementById('stat-answered');
        const statCorrect = document.getElementById('stat-correct');
        const statAccuracy = document.getElementById('stat-accuracy');
        const statAvgBrier = document.getElementById('stat-avg-brier');
        const calibrationChartCtx = document.getElementById('calibrationChart').getContext('2d');

        // Game State
        let currentQuestionData = null;
        let selectedAnswer = null;
        let calibrationChart = null;
        // Generate a simple session ID for frontend use if needed
        const sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

        // --- Utility Functions ---
        function showLoading() { loadingElement.style.display = 'block'; errorMessageElement.textContent = ''; }
        function hideLoading() { loadingElement.style.display = 'none'; }
        function showQuestion() { questionContainer.style.display = 'block'; }
        function hideQuestion() { questionContainer.style.display = 'none'; }
        function displayError(message) { errorMessageElement.textContent = message; console.error("Displaying Error:", message); }
        function clearError() { errorMessageElement.textContent = ''; }

        // --- Core Game Logic ---

        function fetchNewQuestion() {
            showLoading();
            hideQuestion();
            clearError();

            fetch('/get_trivia_question')
                .then(response => {
                    if (!response.ok) { // Check for HTTP errors (like 503)
                         return response.json().then(errData => {
                            throw new Error(errData.error || `HTTP error ${response.status}`);
                         });
                    }
                    return response.json();
                })
                .then(data => {
                    hideLoading(); // Hide loading once data starts processing
                    if (data.error) { // Handle logical errors returned in JSON
                        displayError(data.error);
                        return;
                    }
                    currentQuestionData = data; // Store the whole response

                    console.log("Received data for question:", currentQuestionData); // Log received data

                    // Display question and source link
                    questionTextElement.textContent = currentQuestionData.question;
                    wikiLinkElement.href = currentQuestionData.wiki_page_url;
                    wikiLinkElement.textContent = `(Source: ${currentQuestionData.wiki_page_title})`;
                    wikiLinkElement.style.display = 'inline';

                    optionsElement.innerHTML = ''; // Clear previous options

                    // --- Robustly Display Options ---
                    // Add explicit logging right before the loop
                    console.log('Attempting to process options:', currentQuestionData.options);
                    if (typeof currentQuestionData.options !== 'object' || currentQuestionData.options === null) {
                         console.error('ERROR: currentQuestionData.options is not an object!', currentQuestionData.options);
                         displayError('Received invalid question options format.');
                         return; // Stop processing if options aren't an object
                    }

                    try { // Add try...catch around button creation
                        const optionLetters = Object.keys(currentQuestionData.options);
                        // Optional: Shuffle the order letters are displayed
                        optionLetters.sort(() => Math.random() - 0.5);

                        optionLetters.forEach(letter => {
                            if (currentQuestionData.options.hasOwnProperty(letter)) {
                                const text = currentQuestionData.options[letter];
                                const li = document.createElement('li');
                                const button = document.createElement('button');
                                button.textContent = `${letter}) ${text}`;
                                button.classList.add('option-button');
                                button.dataset.answerLetter = letter; // Store the letter

                                button.onclick = () => {
                                    // Handle selection UI
                                    const currentlySelected = optionsElement.querySelector('.selected');
                                    if (currentlySelected) {
                                        currentlySelected.classList.remove('selected');
                                    }
                                    button.classList.add('selected');
                                    selectedAnswer = letter; // Store the selected letter
                                    submitButton.disabled = confidenceSlider.value === null; // Keep disabled if slider broken? Or just enable? Let's enable.
                                    submitButton.disabled = false;
                                };
                                li.appendChild(button);
                                optionsElement.appendChild(li);
                            }
                        });
                    } catch (loopError) {
                        console.error("Error creating option buttons:", loopError);
                        console.error("Data during error:", currentQuestionData.options); // Log data when error occurs
                        displayError("Error displaying question options.");
                        return; // Stop if loop fails
                    }
                    // --- End Robust Display ---

                    // Reset UI elements
                    resultElement.textContent = '';
                    resultElement.className = '';
                    submitButton.disabled = true; // Disable until an option is selected
                    confidenceSlider.value = 50;
                    confidenceValueElement.textContent = '50%';
                    selectedAnswer = null;

                    showQuestion(); // Show the prepared question area
                })
                .catch(error => { // Catch fetch errors or errors thrown from response check
                    console.error('Error fetching or processing question:', error);
                    // Display the error message from the exception
                    displayError(error.message || 'Failed to fetch question. Please try again.');
                    hideLoading();
                });
        }

        function submitAnswer() {
            if (!selectedAnswer) return; // Should not happen if button logic is correct

            const confidence = parseInt(confidenceSlider.value, 10);
            showLoading(); // Indicate processing
            clearError();

            fetch('/submit_answer', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ answer: selectedAnswer, confidence: confidence })
            })
            .then(response => {
                if (!response.ok) { // Check for HTTP errors
                    return response.json().then(errData => { throw new Error(errData.error || `HTTP error ${response.status}`); });
                }
                return response.json();
            })
            .then(resultData => {
                hideLoading();
                if (resultData.error){
                     displayError(resultData.error);
                     return;
                }

                // Display result feedback
                resultElement.textContent = `Result: ${resultData.result}. Correct Answer: ${resultData.correct_answer}) ${resultData.correct_answer_text}. Brier Score: ${resultData.brier_score}`;
                resultElement.className = resultData.result; // 'correct' or 'incorrect' class

                // Highlight buttons
                const buttons = optionsElement.querySelectorAll('.option-button');
                buttons.forEach(button => {
                    button.disabled = true; // Disable after answering
                    const btnLetter = button.dataset.answerLetter;
                    if (btnLetter === resultData.correct_answer) {
                        button.classList.add('correct');
                    } else if (btnLetter === selectedAnswer) {
                        button.classList.add('incorrect');
                    }
                     // Remove selection highlight? Optional.
                    button.classList.remove('selected');
                });

                // Update displayed stats and chart
                updateStats(resultData.new_stats);
                fetchCalibrationData(); // Refetch data to update chart

                // Prepare for next question (maybe?) - or rely on user clicking button
                hideQuestion(); // Hide answered question after showing result? Or leave it? Leave it for now.
                // Or maybe just disable submit button again
                submitButton.disabled = true;


            })
            .catch(error => {
                console.error('Error submitting answer:', error);
                displayError(error.message || 'Failed to submit answer.');
                hideLoading();
            });
        }

        // --- Statistics and Charting ---

        function updateStats(stats) {
            statAnswered.textContent = stats.total_answered;
            statCorrect.textContent = stats.total_correct;
            const accuracy = stats.total_answered > 0 ? ((stats.total_correct / stats.total_answered) * 100).toFixed(1) : 'N/A';
            statAccuracy.textContent = accuracy;
            const avgBrier = stats.brier_scores.length > 0 ? (stats.brier_scores.reduce((a, b) => a + b, 0) / stats.brier_scores.length).toFixed(3) : 'N/A';
            statAvgBrier.textContent = avgBrier;
        }

        function fetchStats() {
            // Use the unique session ID
            fetch(`/get_stats?session_id=${sessionId}`) // Add session ID if needed for backend tracking later
                .then(response => response.json())
                .then(stats => updateStats(stats))
                .catch(error => console.error('Error fetching stats:', error));
        }

         function fetchCalibrationData() {
             // Use the unique session ID
            fetch(`/get_calibration_data?session_id=${sessionId}`)
                .then(response => response.json())
                .then(data => {
                    console.log("Calibration data received:", data); // Log data for chart
                    renderCalibrationChart(data);
                })
                .catch(error => console.error('Error fetching calibration data:', error));
        }

        function renderCalibrationChart(data) {
             const points = data.points || []; // Ensure points is an array

             // Prepare data for Chart.js scatter plot
             const chartData = points.map(p => ({
                 x: p.x, // Average confidence in bin
                 y: p.y  // Accuracy in bin
             }));

             // Add ideal calibration line (y=x)
             const perfectLine = [{x: 0, y: 0}, {x: 100, y: 1}]; // Plotting accuracy 0-1 vs confidence 0-100

             if (calibrationChart) {
                calibrationChart.data.datasets[0].data = chartData;
                // calibrationChart.data.datasets[1].data = perfectLine; // Update perfect line too if needed
                calibrationChart.update();
            } else {
                calibrationChart = new Chart(calibrationChartCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Calibration',
                                data: chartData,
                                backgroundColor: 'rgba(0, 0, 255, 0.6)', // Blue dots
                                pointRadius: 5,
                                pointHoverRadius: 7
                            },
                            {
                                label: 'Perfect Calibration',
                                data: perfectLine,
                                type: 'line', // Draw this as a line
                                borderColor: 'rgba(255, 0, 0, 0.5)', // Red line
                                borderWidth: 1,
                                pointRadius: 0, // No points on the line
                                fill: false,
                                tension: 0 // Straight line
                            }
                        ]
                    },
                    options: {
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: { display: true, text: 'Average Confidence (%)' },
                                min: 0,
                                max: 100
                            },
                            y: {
                                title: { display: true, text: 'Accuracy' },
                                min: 0,
                                max: 1 // Accuracy is 0.0 to 1.0
                            }
                        },
                        plugins: {
                             tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        // Find original point data to get count if needed
                                        const pointIndex = context.dataIndex;
                                        const originalPoint = points[pointIndex]; // Assumes points array matches chartData array order
                                        let label = ` Avg Confidence: ${context.parsed.x.toFixed(1)}%`;
                                        label += `, Accuracy: ${(context.parsed.y * 100).toFixed(1)}%`;
                                        if(originalPoint && originalPoint.count){
                                             label += ` (Count: ${originalPoint.count})`;
                                        }
                                        return label;
                                    }
                                }
                             }
                        }
                    }
                });
            }
        }

        // --- Event Listeners ---
        newQuestionButton.addEventListener('click', fetchNewQuestion);
        submitButton.addEventListener('click', submitAnswer);
        confidenceSlider.addEventListener('input', (e) => {
            confidenceValueElement.textContent = `${e.target.value}%`;
        });

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
             fetchStats();
             fetchCalibrationData();
             // Optionally fetch a question automatically on load?
             // fetchNewQuestion();
        });

    </script>

</body>
</html>