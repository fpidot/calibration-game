<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wikipedia Calibration Game</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: auto; }
        #question-container { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9; }
        #options-container ul { list-style: none; padding: 0; }
        #options-container li { margin-bottom: 10px; }
        .option-button { display: block; width: 100%; padding: 10px; text-align: left; background-color: #eee; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
        .option-button:hover { background-color: #ddd; }
        .option-button.selected { background-color: #add8e6; border-color: #87ceeb; }
        .option-button.correct { background-color: #90ee90; border-color: #3cb371; }
        .option-button.incorrect { background-color: #f08080; border-color: #cd5c5c; }
        #confidence-section { margin-top: 20px; }
        #result { margin-top: 15px; padding: 10px; border-radius: 4px; }
        #result.correct { background-color: #dff0d8; border: 1px solid #d6e9c6; color: #3c763d; }
        #result.incorrect { background-color: #f2dede; border: 1px solid #ebccd1; color: #a94442; }
        #stats-container { margin-top: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #fafafa; }
        #calibration-chart-container { margin-top: 20px; max-width: 600px; }
        #loading { display: none; font-style: italic; color: #555; }
        #error-message { color: red; margin-top: 10px; font-weight: bold; }
        .wiki-link { font-size: 0.9em; color: #555; margin-left: 5px; }
    </style>
</head>
<body>

    <h1>Wikipedia Calibration Game</h1>

    <div id="game-area">
        <button id="new-question-button">Get New Question</button>
        <div id="loading">Loading question...</div>

        <div id="question-container" style="display: none;">
            <p id="question-text"></p>
            <a id="wiki-link" href="#" target="_blank" class="wiki-link" style="display: none;"></a>
            <div id="options-container">
                <ul></ul>
            </div>
            <div id="confidence-section">
                <label for="confidence">Confidence (0-100%): </label>
                <input type="range" id="confidence" name="confidence" min="0" max="100" value="25">
                <span id="confidence-value">25%</span>
            </div>
            <button id="submit-answer-button" disabled>Submit Answer</button>
            <div id="result"></div>
        </div>
        <div id="error-message"></div>
    </div>

    <div id="stats-container">
        <h2>Session Statistics</h2>
        <p>Questions Answered (Overall): <span id="stat-answered">0</span></p> {/* Clarify this is overall */}
        <p>Correct Answers (Overall): <span id="stat-correct">0</span> (<span id="stat-accuracy">N/A</span>%)</p>
        <p>Average Brier Score: <span id="stat-avg-brier">N/A</span></p>
        <p>Current Game Score: <span id="stat-total-score">0</span></p> {/* Clarify this is current game score */}
        <p>Question: <span id="stat-game-progress">0</span> / <span id="stat-game-length">20</span></p>
        <div id="calibration-chart-container">
            <canvas id="calibrationChart"></canvas>
        </div>
    </div>

    <script>
        // DOM Elements
        const newQuestionButton = document.getElementById('new-question-button');
        const loadingElement = document.getElementById('loading');
        const questionContainer = document.getElementById('question-container');
        const questionTextElement = document.getElementById('question-text');
        const wikiLinkElement = document.getElementById('wiki-link');
        const optionsElement = document.getElementById('options-container').querySelector('ul');
        const confidenceSlider = document.getElementById('confidence');
        const confidenceValueElement = document.getElementById('confidence-value');
        const submitButton = document.getElementById('submit-answer-button');
        const resultElement = document.getElementById('result');
        const errorMessageElement = document.getElementById('error-message');

        // Stats Elements
        const statAnswered = document.getElementById('stat-answered');
        const statCorrect = document.getElementById('stat-correct');
        const statAccuracy = document.getElementById('stat-accuracy');
        const statAvgBrier = document.getElementById('stat-avg-brier');
        const statTotalScore = document.getElementById('stat-total-score');
        const statGameProgress = document.getElementById('stat-game-progress');
        const statGameLength = document.getElementById('stat-game-length');
        const calibrationChartCtx = document.getElementById('calibrationChart').getContext('2d');

        // Game State
        let currentQuestionData = null;
        let selectedAnswer = null;
        let calibrationChart = null;
        const sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

        // --- Utility Functions ---
        function showLoading() { loadingElement.style.display = 'block'; errorMessageElement.textContent = ''; }
        function hideLoading() { loadingElement.style.display = 'none'; }
        function showQuestion() { questionContainer.style.display = 'block'; }
        // function hideQuestion() { questionContainer.style.display = 'none'; } // We keep question visible after answer
        function displayError(message) { errorMessageElement.textContent = message; console.error("Displaying Error:", message); }
        function clearError() { errorMessageElement.textContent = ''; }

        // --- Core Game Logic ---
        function fetchNewQuestion() {

            if (newQuestionButton.textContent === 'Play Again?') {
                startNewGame();
                return; 
            }
            showLoading();
            questionContainer.style.display = 'none'; // Hide old question area before fetching new
            clearError();

            fetch('/get_trivia_question')
                .then(response => {
                    if (!response.ok) {
                         return response.json().then(errData => { throw new Error(errData.error || `HTTP error ${response.status}`); });
                    }
                    return response.json();
                })
                .then(data => {
                    hideLoading();
                    if (data.error) {
                        displayError(data.error);
                        return;
                    }
                    currentQuestionData = data;
                    console.log("Received data for question:", currentQuestionData);

                    questionTextElement.textContent = currentQuestionData.question;
                    wikiLinkElement.href = currentQuestionData.wiki_page_url;
                    wikiLinkElement.textContent = `(Source: ${currentQuestionData.wiki_page_title})`;
                    wikiLinkElement.style.display = 'inline';
                    optionsElement.innerHTML = '';

                    console.log('Attempting to process options:', currentQuestionData.options);
                    if (typeof currentQuestionData.options !== 'object' || currentQuestionData.options === null) {
                         console.error('ERROR: currentQuestionData.options is not an object!', currentQuestionData.options);
                         displayError('Received invalid question options format.');
                         return;
                    }
                    try {
                        const optionLetters = Object.keys(currentQuestionData.options);
                        optionLetters.sort(() => Math.random() - 0.5);
                        optionLetters.forEach(letter => {
                            if (currentQuestionData.options.hasOwnProperty(letter)) {
                                const text = currentQuestionData.options[letter];
                                const li = document.createElement('li');
                                const button = document.createElement('button');
                                button.textContent = `${letter}) ${text}`;
                                button.classList.add('option-button');
                                button.dataset.answerLetter = letter;
                                button.onclick = () => {
                                    const currentlySelected = optionsElement.querySelector('.selected');
                                    if (currentlySelected) currentlySelected.classList.remove('selected');
                                    button.classList.add('selected');
                                    selectedAnswer = letter;
                                    submitButton.disabled = false;
                                };
                                li.appendChild(button);
                                optionsElement.appendChild(li);
                            }
                        });
                    } catch (loopError) {
                        console.error("Error creating option buttons:", loopError);
                        console.error("Data during error:", currentQuestionData.options);
                        displayError("Error displaying question options.");
                        return;
                    }
                    resultElement.textContent = '';
                    resultElement.className = '';
                    newQuestionButton.textContent = 'Get New Question';
                    document.getElementById('confidence-section').style.display = 'block';
                    submitButton.style.display = 'inline-block';
                    submitButton.disabled = true;
                    confidenceSlider.value = 25; // Reset confidence
                    confidenceValueElement.textContent = '25%';
                    selectedAnswer = null;
                    showQuestion();
                })
                .catch(error => {
                    console.error('Error fetching or processing question:', error);
                    displayError(error.message || 'Failed to fetch question. Please try again.');
                    hideLoading();
                });
        }

                function startNewGame() {
            console.log("Starting a new game...");
            fetch('/start_new_game', { method: 'POST' }) // Create this route in app.py
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        console.log("New game started, session reset by backend.");
                        updateStats(data.new_stats); // Update UI with fresh stats from backend
                        fetchCalibrationData(); // Refetch to clear chart with new data
                        newQuestionButton.textContent = 'Get New Question';
                        document.getElementById('confidence-section').style.display = 'block';
                        submitButton.style.display = 'inline-block';
                        fetchNewQuestion(); // Now fetch the first question
                    } else {
                        displayError("Could not start a new game.");
                    }
                })
                .catch(error => {
                    console.error('Error starting new game:', error);
                    displayError("Error starting new game.");
                });
        }

        function submitAnswer() {
            if (!selectedAnswer) return;
            const confidence = parseInt(confidenceSlider.value, 10);
            showLoading();
            clearError();

            fetch('/submit_answer', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ answer: selectedAnswer, confidence: confidence })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errData => { throw new Error(errData.error || `HTTP error ${response.status}`); });
                }
                return response.json();
            })
            .then(resultData => {
                hideLoading();
                if (resultData.error){
                     displayError(resultData.error);
                     return;
                }

                let feedbackText = `Result: ${resultData.result}. Correct Answer: ${resultData.correct_answer}) ${resultData.correct_answer_text}.`;
                feedbackText += ` Brier Score: ${resultData.brier_score}.`;
                if (resultData.points_awarded !== undefined && resultData.points_awarded !== null) {
                     feedbackText += ` Points: ${resultData.points_awarded.toFixed(1)}`;
                }
                console.log("Final feedbackText to be displayed:", feedbackText);
                console.log("resultData object:", JSON.stringify(resultData, null, 2));

                resultElement.textContent = feedbackText;
                resultElement.className = resultData.result;
                showQuestion(); // Ensure question area (and result div) is visible

                const buttons = optionsElement.querySelectorAll('.option-button');
                buttons.forEach(button => {
                    button.disabled = true;
                    const btnLetter = button.dataset.answerLetter;
                    if (btnLetter === resultData.correct_answer) button.classList.add('correct');
                    else if (btnLetter === selectedAnswer) button.classList.add('incorrect');
                    button.classList.remove('selected');
                });

                updateStats(resultData.new_stats); // This will update the total score display
                fetchCalibrationData();
                // submitButton.disabled = true;
                if (resultData.end_of_game) {
                resultElement.innerHTML += "<br><b>Game Over! Final Score: " + resultData.new_stats.cumulative_score.toFixed(1) + "</b>";
                newQuestionButton.textContent = 'Play Again?';
                // Optionally hide the confidence slider and submit button completely
                document.getElementById('confidence-section').style.display = 'none';
                submitButton.style.display = 'none';
                // Do NOT automatically fetch a new question here.
            } else {
                // If game is not over, re-enable "Get New Question" functionality implicitly
                // The current setup already allows clicking "Get New Question"
                submitButton.disabled = true; // Keep disabled until next question options are chosen
            }
            })
            .catch(error => {
                console.error('Error submitting answer:', error);
                displayError(error.message || 'Failed to submit answer.');
                hideLoading();
            });
        }

        function updateStats(stats) {
            console.log("updateStats called with stats:", JSON.stringify(stats, null, 2));
            if (!stats) { console.error("updateStats called with null or undefined stats object."); return; }

            statAnswered.textContent = stats.total_answered !== undefined ? stats.total_answered : '0';
            statCorrect.textContent = stats.total_correct !== undefined ? stats.total_correct : '0';
            const accuracy = (stats.total_answered && stats.total_answered > 0 && stats.total_correct !== undefined)
                ? ((stats.total_correct / stats.total_answered) * 100).toFixed(1)
                : 'N/A';
            statAccuracy.textContent = accuracy;
            const avgBrier = (stats.brier_scores && stats.brier_scores.length > 0)
                ? (stats.brier_scores.reduce((a, b) => a + b, 0) / stats.brier_scores.length).toFixed(3)
                : 'N/A';
            statAvgBrier.textContent = avgBrier;

            if (stats.hasOwnProperty('cumulative_score') && stats.cumulative_score !== null) {
                let score = parseFloat(stats.cumulative_score);
                if (!isNaN(score)) {
                    statTotalScore.textContent = score.toFixed(1); // This should now work
                    console.log("Cumulative score updated to:", score.toFixed(1));
                } else {
                    console.error("Cumulative score is not a valid number:", stats.cumulative_score);
                    statTotalScore.textContent = 'Error';
                }
            } else {
                console.log("Cumulative score not found or is null in stats object. Defaulting display to 0.");
                statTotalScore.textContent = '0';
            }
            if (stats.hasOwnProperty('questions_this_game')) {
                statGameProgress.textContent = stats.questions_this_game;
            } else {
                statGameProgress.textContent = '0';
            }
                         if (stats.hasOwnProperty('game_length_setting')) { // Assuming backend sends this
                statGameLength.textContent = stats.game_length_setting;
             } else {
                 statGameLength.textContent = 'N/A'; // Or a default like 20
             }
        }

        function fetchStats() {
            fetch(`/get_stats?session_id=${sessionId}`)
                .then(response => response.json())
                .then(stats => updateStats(stats))
                .catch(error => console.error('Error fetching stats:', error));
        }

         function fetchCalibrationData() {
            fetch(`/get_calibration_data?session_id=${sessionId}`)
                .then(response => response.json())
                .then(data => {
                    console.log("Calibration data received:", data);
                    renderCalibrationChart(data);
                })
                .catch(error => console.error('Error fetching calibration data:', error));
        }

        function renderCalibrationChart(data) {
            const points = data.points || [];
            console.log("Rendering calibration chart with points:", points);
            const chartData = points.map(p => ({ x: p.x, y: p.y }));
            const counts = points.map(p => p.count);
            const maxCount = Math.max(1, ...counts);
            const minRadius = 3; const maxRadius = 15;
            const pointRadii = points.map(p => {
                if (p.count <= 0) return minRadius;
                let radius = minRadius + (maxRadius - minRadius) * Math.sqrt(p.count / maxCount);
                return Math.min(radius, maxRadius);
            });
            const perfectLine = [{x: 0, y: 0}, {x: 100, y: 1.0}];

            if (calibrationChart) {
                calibrationChart.data.datasets[0].data = chartData;
                calibrationChart.data.datasets[0].pointRadius = pointRadii;
                calibrationChart.update();
                console.log("Calibration chart updated.");
            } else {
                console.log("Creating new calibration chart.");
                calibrationChart = new Chart(calibrationChartCtx, {
                    type: 'scatter',
                    data: { datasets: [ { label: 'Calibration Bins', data: chartData, backgroundColor: 'rgba(0, 0, 255, 0.7)', borderColor: 'rgba(0, 0, 255, 1)', pointRadius: pointRadii, pointHoverRadius: pointRadii.map(r => r + 2), order: 2 }, { label: 'Perfect Calibration', data: perfectLine, type: 'line', borderColor: 'rgba(200, 200, 200, 0.8)', borderWidth: 2, pointRadius: 0, fill: false, tension: 0, order: 1 } ] },
                    options: { scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Average Confidence in Bin (%)' }, min: 0, max: 100 }, y: { title: { display: true, text: 'Accuracy (Proportion Correct)' }, min: 0, max: 1.0 } }, plugins: { tooltip: { callbacks: { label: function(context) { if (context.datasetIndex === 0) { const pointIndex = context.dataIndex; const originalPoint = points[pointIndex]; if (!originalPoint) return "Data point error"; let label = ` Bin ${pointIndex + 1}:`; label += ` Avg Confidence: ${originalPoint.x.toFixed(1)}%`; label += `, Accuracy: ${(originalPoint.y * 100).toFixed(1)}%`; label += ` (Count: ${originalPoint.count})`; return label; } else { return null; } } } }, legend: { display: true } }, responsive: true, maintainAspectRatio: true }
                });
            }
        }

        // --- Event Listeners ---
        newQuestionButton.addEventListener('click', fetchNewQuestion);
        submitButton.addEventListener('click', submitAnswer);
        confidenceSlider.addEventListener('input', (e) => {
            confidenceValueElement.textContent = `${e.target.value}%`;
        });

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
             fetchStats(); // This will call updateStats, which will try to update total score
             fetchCalibrationData();
        });

    </script>

</body>
</html>