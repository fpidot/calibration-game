{% extends "base.html" %}

{% block title %}Wikipedia Calibration Game{% endblock %}

{% block head_extra %}
    {{ super() }} 
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: auto; }
        .hidden { display: none !important; } 
        #nickname-setup-area, #pre-game-options { 
            margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; 
            border-radius: 5px; background-color: #f0f0f0; 
        }
        #nickname-setup-area label, #pre-game-options label { 
            display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold;
        }
        #nickname-setup-area input[type="text"], #pre-game-options select, #pre-game-options input[type="text"] { 
            width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; 
            border-radius: 4px; box-sizing: border-box; 
        }
        #nickname-error { color: red; font-size: 0.9em; margin-top: -5px; margin-bottom: 10px; min-height: 1em;}
        #question-container { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9; }
        #options-container ul { list-style: none; padding: 0; }
        #options-container li { margin-bottom: 10px; }
        .option-button { display: block; width: 100%; padding: 10px; text-align: left; background-color: #eee; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
        .option-button:hover { background-color: #ddd; }
        .option-button.selected { background-color: #add8e6; border-color: #87ceeb; }
        .option-button.correct { background-color: #90ee90; border-color: #3cb371; }
        .option-button.incorrect { background-color: #f08080; border-color: #cd5c5c; }
        #confidence-section { margin-top: 20px; }
        #result { margin-top: 15px; padding: 10px; border-radius: 4px; }
        #result.correct { background-color: #dff0d8; border: 1px solid #d6e9c6; color: #3c763d; }
        #result.incorrect { background-color: #f2dede; border: 1px solid #ebccd1; color: #a94442; }
        #stats-container { margin-top: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #fafafa; }
        #calibration-chart-container { margin-top: 20px; max-width: 600px; }
        #loading { display: none; font-style: italic; color: #555; }
        #error-message { color: red; margin-top: 10px; font-weight: bold; min-height: 1em;}
        .game-over-message { font-weight: bold; margin-top: 10px; }
        #displayed-category { 
            font-size: 0.9em; color: #555; margin-bottom: 10px; 
            font-style: italic; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        .hidden { display: none !important; } 
        #nickname-setup-area, #pre-game-options { 
            margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; 
            border-radius: 5px; background-color: #f0f0f0;
        }
                #category-stats-container { 
            margin-top: 30px; 
            padding: 15px; 
            border: 1px solid #ddd; 
            border-radius: 5px; 
            background-color: #fdfdfd; 
        }
        #category-stats-container h2 {
            margin-top: 0;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .stats-table th {
            background-color: #f2f2f2;
        }
        .stats-table tr:nth-child(even){background-color: #f9f9f9;}
        .stats-table tr:hover {background-color: #efefef;}
        .stats-table th[data-sort-by] {
            cursor: pointer;
        }
        .stats-table th[data-sort-by]:hover {
            background-color: #e0e0e0;
        }
        .stats-table .sort-arrow {
            font-size: 0.8em;
            margin-left: 5px;
        }
        .option-button.correct { 
            background-color: #90ee90; /* Light green */
            border-color: #3cb371; 
            color: #155724; /* Darker green text for contrast */
        }
        .option-button.incorrect { 
            background-color: #f08080; /* Light red */
            border-color: #cd5c5c; 
            color: #721c24; /* Darker red text */
        }

    </style>
{% endblock %}

{% block content %}

<div id="user-info-display" style="text-align: right; margin-bottom: 10px; font-size: 0.9em;">
    Playing as: <strong id="user-nickname-text">Guest</strong>
</div>

<div id="nickname-setup-area" class="hidden">
    <h2>Welcome! Choose Your Nickname</h2>
    <label for="nickname-input">Enter your desired nickname:</label>
    <input type="text" id="nickname-input" name="nickname">
    <div id="nickname-error"></div>
    <button id="confirm-nickname-button">Confirm Nickname</button>
    <p style="font-size:0.8em; color: #555;">(Letters, numbers, and underscores only. 3-30 characters.)</p>
</div>

<div id="pre-game-options" class="hidden">
    <h2>Game Setup</h2>
    <div id="category-selection-area">
        <label for="prefab-category-select">Choose a Category:</label>
        <select id="prefab-category-select" name="prefab_category">
            <option value="random" selected>No specific category (default random)</option>
        </select>
        <label for="custom-category-input">Or enter your own topic/keywords:</label>
        <input type="text" id="custom-category-input" name="custom_category" placeholder="e.g., Renaissance Painters, Quantum Physics">
        <small>If you enter a custom topic, it will be used instead of the dropdown selection.</small>
    </div>
</div>

<div id="complete-registration-prompt" class="hidden" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404; border-radius: .25rem; text-align: center;"></div>

<h1>Wikipedia Calibration Game</h1>

<div id="game-area" class="hidden"> <!-- Initially hidden if nickname setup is needed -->
    <button id="new-question-button" class="hidden">Begin Game</button>
    <div id="loading">Loading question...</div>
    <div id="question-container" style="display: none;">
        <p id="displayed-category" style="display: none;"></p>
        <p id="question-text"></p>
        <a id="wiki-link" href="#" target="_blank" style="display: none;"></a> 
        <div id="options-container"><ul></ul></div>
        <div id="confidence-section">
            <label for="confidence">Confidence (0-100%): </label>
            <input type="range" id="confidence" name="confidence" min="0" max="100" value="25">
            <span id="confidence-value">25%</span>
        </div>
        <button id="submit-answer-button" disabled>Submit Answer</button>
        <div id="result"></div>
    </div>
    <div id="error-message"></div>
</div>

<div id="stats-container">
    {% if current_user.is_authenticated %}
        <h2>Lifetime Statistics</h2>
        {# --- Overall Lifetime Stats for Logged-in User --- #}
        {% if overall_lifetime_stats %}
            <h4>Overall Performance</h4>
            <p>Total Questions Answered: <span id="lifetime-stat-answered">{{ overall_lifetime_stats.total_questions }}</span></p>
            <p>Total Correct Answers: <span id="lifetime-stat-correct">{{ overall_lifetime_stats.total_correct }}</span> (<span id="lifetime-stat-accuracy">{{ overall_lifetime_stats.accuracy }}</span>%)</p>
            <p>Overall Average Brier Score: <span id="lifetime-stat-avg-brier">{{ "%.3f"|format(overall_lifetime_stats.average_brier) if overall_lifetime_stats.average_brier is not none else 'N/A' }}</span></p>
            <p>Total Lifetime Points: <span id="lifetime-stat-total-points">{{ overall_lifetime_stats.total_points }}</span></p>
            <hr>
        {% endif %}

        {% if personal_best_game_score or personal_best_game_brier %}
            <h4>Personal Best Games</h4>
            <ul style="list-style-type: none; padding-left: 0;">
                {% if personal_best_game_score %}
                <li>
                    <strong>Highest Scoring Game:</strong> {{ "%.1f"|format(personal_best_game_score.score) }}
                    (Category: {{ personal_best_game_score.category }}, 
                    On: {{ personal_best_game_score.date.strftime('%b %d, %Y') }})
                </li>
                {% endif %}
                {% if personal_best_game_brier %}
                <li style="margin-top: 5px;">
                    <strong>Best Calibrated Game (Lowest Brier):</strong> {{ "%.3f"|format(personal_best_game_brier.brier) }}
                    (Category: {{ personal_best_game_brier.category }}, 
                    Score: {{ "%.1f"|format(personal_best_game_brier.score_in_that_game) }},
                    On: {{ personal_best_game_brier.date.strftime('%b %d, %Y') }})
                </li>
                {% endif %}
            </ul>
            <hr>
        {% endif %}

        {# --- Current Game Progress (from session, for logged-in user) --- #}
        {% if current_game_progress_stats %}
            <h4>Current Game</h4>
            <p>Score This Game: <span id="stat-total-score">{{ "%.1f"|format(current_game_progress_stats.current_game_score) }}</span></p>
            <p>Question: <span id="stat-game-progress">{{ current_game_progress_stats.questions_this_game }}</span> / <span id="stat-game-length">{{ current_game_progress_stats.game_length_setting }}</span></p>
            {# Add current game avg brier if desired: calculate from session['stats']['game_brier_scores'] in Python and pass #}
            <hr>
        {% endif %}

    {% elif session_stats_for_guest %} {# Guest or Nickname-only User - Display Session Stats #}
        <h2>Your Current Statistics</h2>
        <p>Questions Answered (This Session): <span id="stat-answered">{{ session_stats_for_guest.total_answered }}</span></p>
        <p>Correct Answers (This Session): <span id="stat-correct">{{ session_stats_for_guest.total_correct }}</span> (<span id="stat-accuracy">{{ (session_stats_for_guest.total_correct / session_stats_for_guest.total_answered * 100)|round(1,'floor') if session_stats_for_guest.total_answered > 0 else 'N/A' }}</span>%)</p>
        <p>Average Brier Score (Current Game): <span id="stat-game-avg-brier">{{ ("%.3f"|format(session_stats_for_guest.game_brier_scores|sum / session_stats_for_guest.game_brier_scores|length)) if session_stats_for_guest.game_brier_scores else 'N/A' }}</span></p>
        <p>Average Brier Score (This Session): <span id="stat-session-avg-brier">{{ ("%.3f"|format(session_stats_for_guest.brier_scores|sum / session_stats_for_guest.brier_scores|length)) if session_stats_for_guest.brier_scores else 'N/A' }}</span></p>
        <p>Score This Game: <span id="stat-total-score">{{ "%.1f"|format(session_stats_for_guest.cumulative_score) }}</span></p>
        <p>Question: <span id="stat-game-progress">{{ session_stats_for_guest.questions_this_game }}</span> / <span id="stat-game-length">{{ get_setting('game_length', 20) }}</span></p> {# Fetch game_length setting #}
        <p>Games Played (This Session): <span id="stat-games-played">{{ session_stats_for_guest.games_played_session }}</span></p>
        {# Avg Game Score (Session) would require completed_game_scores_session #}
        <hr>
    {% endif %}
    <div id="calibration-chart-controls" style="margin-top:10px; margin-bottom:10px;">
    <label for="chart-bins-select">Chart Bins:</label>
    <select id="chart-bins-select">
            <option value="5">5 Bins</option>
            <option value="10" selected>10 Bins (Default)</option>
            <option value="20">20 Bins</option>
            <option value="50">50 Bins</option>
    </select>
</div>
    <div id="calibration-chart-container"><canvas id="calibrationChart"></canvas></div>
</div>

    {% if current_user.is_authenticated %}
    <div id="category-stats-container"> {# A single container for all lifetime category info #}
        <h2>Lifetime Performance by Category</h2>

        {% if category_stats %}
            {# Display the table of category stats #}
        <table class="stats-table" id="categoryStatsTable">
            <thead>
                <tr>
                    <th data-sort-by="category_name" data-sort-type="alpha">Category</th>
                    <th data-sort-by="total_questions" data-sort-type="numeric">Questions</th>
                    <th data-sort-by="total_correct" data-sort-type="numeric">Correct</th>
                    <th data-sort-by="accuracy" data-sort-type="numeric">Accuracy</th>
                    <th data-sort-by="average_brier" data-sort-type="numeric" class="sortable-header current-sort-asc">Avg. Brier <span class="sort-arrow">â–²</span></th>
                    <th data-sort-by="average_points" data-sort-type="numeric">Avg. Points</th>
                    <th>Action</th> {# NEW COLUMN #}
                </tr>
            </thead>
            <tbody>
                {% for stat_item in category_stats %}
                <tr>
                    <td>{{ stat_item.category_name }}</td>
                    <td>{{ stat_item.total_questions }}</td>
                    <td>{{ stat_item.total_correct }}</td>
                    <td>{{ stat_item.accuracy }}%</td>
                    <td>{{ "%.3f"|format(stat_item.average_brier) if stat_item.average_brier is not none else 'N/A' }}</td>
                    <td>{{ "%.1f"|format(stat_item.average_points) if stat_item.average_points is not none else 'N/A' }}</td>
                    <td>
                        {# Link will go to index, JS will pick up category and start game #}
                        {# We need to handle "Custom: Topic" differently from prefab categories #}
                        {% set category_param_name = 'user_category_prefab' %}
                        {% set category_param_value = stat_item.category_name %}
                        {% if stat_item.category_name.startswith('Custom: ') %}
                            {# For custom categories, we'd ideally pass the original search term if we had it.
                            Since we only have "Custom: Processed Theme", we can pass this as a custom search.
                            The get_trivia_question route already handles 'user_category_custom'.
                            Or, we treat "Custom: Processed Theme" as a prefab name if standardized names are unique.
                            Let's assume for now 'user_category_custom' is better for these.
                            #}
                            {% set category_param_name = 'user_category_custom' %}
                            {% set category_param_value = stat_item.category_name.replace('Custom: ', '', 1) %}
                        {% endif %}
                        <button class="btn btn-sm btn-outline-primary play-category-button" 
                                data-category-type="{{ category_param_name }}" 
                                data-category-value="{{ category_param_value }}">Play This</button>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>

            {# Now, decide whether to show highlights OR the "play more for highlights" message #}
            {% if best_brier_category or best_score_category %}
                <div style="margin-top: 20px;">
                    <h4>Category Highlights (min. {{ get_setting('min_questions_for_cat_rank', 5) }} questions per category):</h4>
                    <ul style="list-style-type: none; padding-left: 0;">
                        {% if best_brier_category %}
                        <li>
                            <strong>Best Calibration (Lowest Avg. Brier):</strong> 
                            {{ best_brier_category.category_name }} 
                            (Avg. Brier: {{ "%.3f"|format(best_brier_category.average_brier) }}, 
                            {{ best_brier_category.total_questions }} questions)
                        </li>
                        {% endif %}
                        {% if worst_brier_category and best_brier_category and worst_brier_category.category_name != best_brier_category.category_name %}
                        <li>
                            <strong>Highest Avg. Brier:</strong> 
                            {{ worst_brier_category.category_name }} 
                            (Avg. Brier: {{ "%.3f"|format(worst_brier_category.average_brier) }}, 
                            {{ worst_brier_category.total_questions }} questions)
                        </li>
                        {% endif %}
                        {% if best_score_category %}
                        <li style="margin-top: 5px;">
                            <strong>Highest Avg. Score:</strong> 
                            {{ best_score_category.category_name }} 
                            (Avg. Score: {{ "%.1f"|format(best_score_category.average_points) }}, 
                            {{ best_score_category.total_questions }} questions)
                        </li>
                        {% endif %}
                        {% if worst_score_category and best_score_category and worst_score_category.category_name != best_score_category.category_name %}
                        <li>
                            <strong>Lowest Avg. Score:</strong> 
                            {{ worst_score_category.category_name }} 
                            (Avg. Score: {{ "%.1f"|format(worst_score_category.average_points) }}, 
                            {{ worst_score_category.total_questions }} questions)
                        </li>
                        {% endif %}
                    </ul>
                </div>
            {% else %} {# This 'else' pairs with 'if best_brier_category or best_score_category' #}
                 <p style="margin-top: 10px;"><em>Play more questions in categories (or at least {{ get_setting('min_questions_for_cat_rank', 5) }} per category) to see highlights here.</em></p>
            {% endif %}

        {% else %} {# This 'else' pairs with 'if category_stats' (i.e., user is authenticated but has NO category stats at all) #}
            <p>No game data found yet for your account. Play some games to see your stats here!</p>
        {% endif %}
    </div>
{% endif %}
{% endblock %}

{% block scripts %}
    {{ super() }}
<script>
    // DOM Elements
    const gameArea = document.getElementById('game-area'); 
    const displayedCategoryElement = document.getElementById('displayed-category');
    const newQuestionButton = document.getElementById('new-question-button');
    const loadingElement = document.getElementById('loading');
    const questionContainer = document.getElementById('question-container');
    const questionTextElement = document.getElementById('question-text');
    const optionsElement = document.getElementById('options-container').querySelector('ul');
    const confidenceSlider = document.getElementById('confidence');
    const confidenceValueElement = document.getElementById('confidence-value');
    const submitButton = document.getElementById('submit-answer-button');
    const resultElement = document.getElementById('result');
    const errorMessageElement = document.getElementById('error-message');
    const userNicknameTextElement = document.getElementById('user-nickname-text');

    const nicknameSetupArea = document.getElementById('nickname-setup-area');
    const nicknameInputElement = document.getElementById('nickname-input');
    const confirmNicknameButton = document.getElementById('confirm-nickname-button');
    const nicknameErrorElement = document.getElementById('nickname-error');

    const preGameOptionsDiv = document.getElementById('pre-game-options');
    const prefabCategorySelect = document.getElementById('prefab-category-select');
    const customCategoryInput = document.getElementById('custom-category-input');
    const chartBinsSelect = document.getElementById('chart-bins-select');

    const statAnswered = document.getElementById('stat-answered'); const statCorrect = document.getElementById('stat-correct'); const statAccuracy = document.getElementById('stat-accuracy'); const statGameAvgBrier = document.getElementById('stat-game-avg-brier'); const statSessionAvgBrier = document.getElementById('stat-session-avg-brier'); const statTotalScore = document.getElementById('stat-total-score'); const statGameProgress = document.getElementById('stat-game-progress'); const statGameLength = document.getElementById('stat-game-length'); const statGamesPlayed = document.getElementById('stat-games-played'); const statAvgGameScore = document.getElementById('stat-avg-game-score'); const calibrationChartCtx = document.getElementById('calibrationChart').getContext('2d');
    
    let currentQuestionData = null; 
    let selectedAnswer = null;
    let calibrationChart = null;
    let lastAnswerFeedbackFromServer = null;
    let points = [];

    function isGameInProgress() {
        const gameNotEndedInFeedback = lastAnswerFeedbackFromServer && !lastAnswerFeedbackFromServer.end_of_game;
        const inProgress = !!currentQuestionData || gameNotEndedInFeedback;
        // console.log(`isGameInProgress: currentQ=${!!currentQuestionData}, feedbackActiveNotEnded=${gameNotEndedInFeedback}, result=${inProgress}`);
        return inProgress;
    }

    function showPreGameOptions() {
        if (preGameOptionsDiv) preGameOptionsDiv.classList.remove('hidden');
        if (newQuestionButton) {
            newQuestionButton.textContent = 'Begin Game';
            newQuestionButton.disabled = false;
            newQuestionButton.classList.remove('hidden');
        }
        if (questionContainer) questionContainer.style.display = 'none'; // Hide active question/feedback area
        currentQuestionData = null; // No active question
        lastAnswerFeedbackFromServer = null; // No active feedback
        if (resultElement) resultElement.textContent = ''; // Clear result text
        console.log("UI: Switched to Pre-Game Options state");
    }


    function displayAnswerFeedback(feedbackData) {
    if (!feedbackData) return;

    lastAnswerFeedbackFromServer = feedbackData; // Set this
    currentQuestionData = null;                // Clear this
    // Set category display first
    if (feedbackData.display_category_name && displayedCategoryElement) {
        displayedCategoryElement.textContent = `Category: ${feedbackData.display_category_name}`;
        displayedCategoryElement.style.display = 'block';
    } else if (displayedCategoryElement) {
        displayedCategoryElement.style.display = 'none'; // Hide if no category name
    }

    // Set the question text
    questionTextElement.textContent = feedbackData.question_text || "Reviewing Answer"; // Show old question

    // --- Re-render options with highlighting ---
    optionsElement.innerHTML = ''; // Clear previous options ONCE before re-rendering
    if (feedbackData.options && typeof feedbackData.options === 'object') {
        const optionLetters = Object.keys(feedbackData.options).sort(); 
        optionLetters.forEach(letter => {
            if (feedbackData.options.hasOwnProperty(letter)) {
                const text = feedbackData.options[letter];
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.textContent = `${letter}) ${text}`;
                button.classList.add('option-button');
                button.disabled = true; // Disable buttons in feedback mode

                // Apply highlighting
                if (letter === feedbackData.correct_answer_letter) {
                    button.classList.add('correct');
                } else if (feedbackData.user_answer_letter && letter === feedbackData.user_answer_letter) {
                    // This condition implies it's the user's answer AND it's not the correct one (because the 'if correct' was first)
                    // So, if it's the user's answer and it wasn't correct, mark it as incorrect.
                    button.classList.add('incorrect'); 
                }
                // No other classes needed for options that were neither correct nor selected by user.

                li.appendChild(button);
                optionsElement.appendChild(li);
            }
        });
    }
    // --- Options are now rendered. Do NOT clear optionsElement.innerHTML again ---

    // Set the main feedback text (result, Brier, points)
    let feedbackText = `Result: ${feedbackData.result}. Correct Answer: ${feedbackData.correct_answer_letter}) ${feedbackData.correct_answer_text}. Brier Score: ${feedbackData.brier_score.toFixed(3)}.`;
    if (feedbackData.points_awarded !== undefined && feedbackData.points_awarded !== null) {
        feedbackText += ` Points: ${feedbackData.points_awarded.toFixed(1)}`;
    }
    resultElement.textContent = feedbackText;
    resultElement.className = feedbackData.result; // 'correct' or 'incorrect' for the result div's background

    // Hide elements not relevant in feedback mode
    if (document.getElementById('wiki-link')) {
         document.getElementById('wiki-link').style.display = 'none';
    }
    document.getElementById('confidence-section').style.display = 'none';
    submitButton.style.display = 'none';

    // Update stats and chart
    updateStats(feedbackData.new_stats, "feedbackDisplay");
    fetchCalibrationData(); 

    showQuestionUi(); // Ensure the main container for question text, options, and result is visible
    
    // Handle "Next Question" / "Play Again?" button state
    if (feedbackData.end_of_game) {
        let gameBrierForDisplay = "N/A";
        if (feedbackData.new_stats.game_brier_scores && feedbackData.new_stats.game_brier_scores.length > 0) {
            gameBrierForDisplay = (feedbackData.new_stats.game_brier_scores.reduce((a, b) => a + b, 0) / feedbackData.new_stats.game_brier_scores.length).toFixed(3);
        }
        resultElement.innerHTML += `<br><div class="game-over-message">Game Over! Final Score: ${feedbackData.new_stats.cumulative_score.toFixed(1)}. Avg Brier (This Game): ${gameBrierForDisplay}</div>`;
        newQuestionButton.textContent = 'Play Again?';
    } else {
        newQuestionButton.textContent = 'Get Next Question';
    }
    newQuestionButton.disabled = false;
    newQuestionButton.classList.remove('hidden');
    preGameOptionsDiv.classList.add('hidden'); // Keep pre-game options hidden during feedback

    hideLoading(); // Ensure loading spinner is hidden
}

    function showLoading() { loadingElement.style.display = 'block'; clearError(); clearError(false); }
    function hideLoading() { loadingElement.style.display = 'none'; }
    function showQuestionUi() { questionContainer.style.display = 'block'; }
    function hideQuestionUi() { 
        questionContainer.style.display = 'none';
        if (displayedCategoryElement) {
             displayedCategoryElement.textContent = '';
             displayedCategoryElement.style.display = 'none';
        }
    }
    function displayError(message, isGlobal = true) { 
        if (isGlobal) errorMessageElement.textContent = message;
        else nicknameErrorElement.textContent = message;
        console.error("Displaying Error:", message); 
    }
    function clearError(isGlobal = true) { 
        if (isGlobal) errorMessageElement.textContent = ''; 
        else nicknameErrorElement.textContent = '';
    }

    function handleNicknameSetup(needsSetup, suggestedNickname, currentConfirmedNicknameForSetup) {
        clearError(); clearError(false); 
        if (needsSetup) {
            nicknameSetupArea.classList.remove('hidden');
            preGameOptionsDiv.classList.add('hidden');
            newQuestionButton.classList.add('hidden');
            gameArea.classList.add('hidden'); 
            nicknameInputElement.value = suggestedNickname || '';
            userNicknameTextElement.textContent = "Choosing nickname...";
        } else {
            nicknameSetupArea.classList.add('hidden');
            gameArea.classList.remove('hidden'); 
            userNicknameTextElement.textContent = currentConfirmedNicknameForSetup || "Guest";
            if (!currentQuestionData) { 
                 preGameOptionsDiv.classList.remove('hidden');
                 newQuestionButton.classList.remove('hidden');
                 newQuestionButton.textContent = 'Begin Game';
                 newQuestionButton.disabled = false;
            } else {
                preGameOptionsDiv.classList.add('hidden'); // Hide if question is active
                newQuestionButton.classList.remove('hidden'); // But game button may be visible (renderQuestion will disable)
            }
        }
    }

    confirmNicknameButton.addEventListener('click', () => {
        const chosenNickname = nicknameInputElement.value.trim();
        nicknameErrorElement.textContent = ''; 
        showLoading();

        fetch('/set_nickname', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ nickname: chosenNickname })
        })
        .then(response => response.json())
        .then(data => {
            hideLoading();
            if (data.status === 'success') {
                window.location.reload(); 
            } else {
                displayError(data.message || "Error setting nickname.", false);
            }
        })
        .catch(error => {
            hideLoading();
            console.error('Error setting nickname:', error);
            displayError("Could not save nickname. Please try again.", false);
        });
    });
    
    function fetchUserCategories() {
        fetch('/get_user_selectable_categories')
            .then(response => { if (!response.ok) throw new Error(`HTTP error ${response.status}`); return response.json();})
            .then(data => {
                if (data.categories && Array.isArray(data.categories)) {
                    while (prefabCategorySelect.options.length > 1) { prefabCategorySelect.remove(1); }
                    data.categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category; option.textContent = category;
                        prefabCategorySelect.appendChild(option);
                    });
                } else { console.warn("No categories data received:", data); }
            })
            .catch(error => console.error('Error fetching user categories:', error));
    }

    function renderQuestion(questionDataFromServer) { 
        currentQuestionData = questionDataFromServer; // Set this
        lastAnswerFeedbackFromServer = null;        // Clear this
        console.log("Rendering question:", currentQuestionData);
        clearError(); 

        if (currentQuestionData.display_category_name) {
            displayedCategoryElement.textContent = `Category: ${currentQuestionData.display_category_name}`;
            displayedCategoryElement.style.display = 'block';
        } else {
            displayedCategoryElement.textContent = '';
            displayedCategoryElement.style.display = 'none';
        }
        questionTextElement.textContent = currentQuestionData.question;
        optionsElement.innerHTML = '';
        const optionLetters = ['A', 'B', 'C', 'D'];
        optionLetters.forEach(letter => {
            if (currentQuestionData.options && currentQuestionData.options.hasOwnProperty(letter)) {
                const text = currentQuestionData.options[letter];
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.textContent = `${letter}) ${text}`;
                button.classList.add('option-button');
                button.dataset.answerLetter = letter;
                button.onclick = () => { 
                    const currentlySelected = optionsElement.querySelector('.selected');
                    if (currentlySelected) currentlySelected.classList.remove('selected');
                    button.classList.add('selected');
                    selectedAnswer = letter;
                    submitButton.disabled = false;
                };
                li.appendChild(button); optionsElement.appendChild(li);
            }
        });
        resultElement.textContent = ''; resultElement.className = '';
        submitButton.disabled = true;
        confidenceSlider.value = 25; confidenceValueElement.textContent = '25%';
        selectedAnswer = null;
        document.getElementById('confidence-section').style.display = 'block';
        submitButton.style.display = 'inline-block';
        
        newQuestionButton.classList.remove('hidden'); 
        newQuestionButton.disabled = true; 

        preGameOptionsDiv.classList.add('hidden'); 
        nicknameSetupArea.classList.add('hidden'); 
        showQuestionUi();
    }
    
    function handleBackendActionError(error, actionType = "operation") {
        console.error(`Error during ${actionType}:`, error);
        let message = error.message || `Failed to complete ${actionType}.`;
        
        if (error.action_needed === "complete_nickname_setup") {
            message = error.message || "Please set your nickname before continuing.";
            displayError(message); 
            
            sessionStorage.setItem('force_nickname_setup', 'true');
            const currentNickInput = nicknameInputElement.value;
            const currentTopDisplayNick = userNicknameTextElement.textContent;
            if (currentNickInput) {
                sessionStorage.setItem('suggested_nickname_temp', currentNickInput);
            } else if (currentTopDisplayNick && currentTopDisplayNick !== "Guest" && currentTopDisplayNick !== "Choosing nickname...") {
                 sessionStorage.setItem('suggested_nickname_temp', currentTopDisplayNick);
            }
            window.location.reload(); 
            return; 
        } else {
            displayError(message); 
        }
        hideLoading();
        if (nicknameSetupArea.classList.contains('hidden')) { 
            if (!currentQuestionData || newQuestionButton.textContent === "Play Again?") {
                 newQuestionButton.disabled = false;
            }
        }
    }

    function fetchNewQuestion() {
        showLoading(); 
        hideQuestionUi(); 
        newQuestionButton.disabled = true; 
        preGameOptionsDiv.classList.add('hidden');
        const customCategory = customCategoryInput.value.trim();
        const selectedPrefabCategory = prefabCategorySelect.value;
        let categoryParams = '';
        if (customCategory) categoryParams = `user_category_custom=${encodeURIComponent(customCategory)}`;
        else if (selectedPrefabCategory && selectedPrefabCategory !== 'random') categoryParams = `user_category_prefab=${encodeURIComponent(selectedPrefabCategory)}`;
        const fetchUrl = `/get_trivia_question${categoryParams ? '?' + categoryParams : ''}`;
        
        fetch(fetchUrl)
            .then(response => {
                if (!response.ok) { return response.json().then(errData => { errData.status = response.status; throw errData; }).catch(() => { throw { message: `HTTP error ${response.status}`, status: response.status };});}
                return response.json();
            })
            .then(data => {
                hideLoading();
                if (data.error && data.action_needed === "complete_nickname_setup") { handleBackendActionError(data, "fetching question");
                } else if (data.error) { 
                    displayError(data.error); newQuestionButton.disabled = false; 
                    if (newQuestionButton.textContent !== 'Play Again?' && nicknameSetupArea.classList.contains('hidden')) preGameOptionsDiv.classList.remove('hidden');
                } else { renderQuestion(data); }
            })
            .catch(error => {
                handleBackendActionError(error, "fetching question");
                 if (error.action_needed !== "complete_nickname_setup" && !currentQuestionData) {
                     newQuestionButton.disabled = false;
                     if (nicknameSetupArea.classList.contains('hidden')) preGameOptionsDiv.classList.remove('hidden'); 
                }
            });
    }


function submitAnswer() {
    if (!selectedAnswer) {
        // displayError("Please select an answer."); // Or some other UI feedback
        return;
    }
    const confidence = parseInt(confidenceSlider.value, 10);

    showLoading(); 
    fetch('/submit_answer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ answer: selectedAnswer, confidence: confidence })
    })
    .then(response => {
        if (!response.ok) {
            // Try to parse error JSON from backend, then throw
            return response.json().then(errData => { 
                errData.status = response.status; // Add status to error object
                throw errData; 
            }).catch(() => { // If parsing error JSON fails, throw a generic error
                throw { message: `HTTP error ${response.status}`, status: response.status };
            });
        }
        return response.json();
    })
    .then(feedbackData => { // Renamed from resultData for clarity with new flow
        hideLoading();
        // Check for specific action_needed from backend, e.g., nickname setup
        if (feedbackData.error && feedbackData.action_needed === "complete_nickname_setup") {
            handleBackendActionError(feedbackData, "submitting answer"); // Your existing error handler
            return;
        } else if (feedbackData.error){
            displayError(feedbackData.error); // Your existing error display function
            // Decide if newQuestionButton should be re-enabled or state reset
            if (currentQuestionData) { // If there was an active question before error
                 submitButton.disabled = false; // Re-enable submit if appropriate
            }
            return;
        } 
        
        // Successfully got feedback data
        // The backend now stores this in session['last_answer_feedback']
        // and has cleared session['current_question'].
        // We use the returned feedbackData to immediately update the UI.
        displayAnswerFeedback(feedbackData); 
    })
    .catch(error => { 
        hideLoading();
        handleBackendActionError(error, "submitting answer"); // Your existing error handler
        // Ensure UI is in a reasonable state after error, e.g., re-enable submit if appropriate
        if (currentQuestionData && selectedAnswer) { // If there was an active question and an answer was selected
            submitButton.disabled = false;
        }
    });
}

function startNewGame() { 
    showLoading();
    // Clear client-side state immediately to prevent race conditions with UI
    currentQuestionData = null;
    lastAnswerFeedbackFromServer = null;

    return fetch('/clear_last_feedback', { method: 'POST' }) 
        .then(response => {
            // Optional: check response, but /start_new_game also clears feedback server-side
            return fetch('/start_new_game', { method: 'POST' }); 
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(errData => { throw errData; });
            }
            return response.json();
        })
        .then(data => {
            hideLoading();
            if (data.error && data.action_needed === "complete_nickname_setup") {
                handleBackendActionError(data, "starting new game");
                throw new Error("Nickname setup required by startNewGame"); 
            } else if (data.status !== 'success') { 
                displayError(data.message || "Could not start new game.");
                if(newQuestionButton) newQuestionButton.disabled = false; // Re-enable on failure
                throw new Error(data.message || "Could not start new game"); 
            }
            
            updateStats(data.new_stats, "startNewGame_js_success");
            fetchCalibrationData(); 

            console.log("New game successfully started (backend acknowledged). Setting UI to pre-game.");
            showPreGameOptions(); // Reset UI to pre-game state
            return data; // Resolve promise with new game data
        })
        .catch(error => { 
            hideLoading();
            if (error && error.action_needed !== "complete_nickname_setup") { 
                handleBackendActionError(error, "starting new game");
            }
            if(newQuestionButton) newQuestionButton.disabled = false; 
            console.error("Error in startNewGame promise chain:", error);
            showPreGameOptions(); // Attempt to reset to a safe UI state on error too
            throw error; // Re-throw to allow further .catch if needed by caller
        });
}

function updateStats(statsDataFromBackend, source = "unknown") { 
    // statsDataFromBackend is the 'new_stats' object from /submit_answer or /start_new_game,
    // or the full stats object from /get_stats (for guests on initial load).

    console.log(`updateStats called FROM ${source} with data:`, JSON.stringify(statsDataFromBackend, null, 2));
    if (!statsDataFromBackend) { 
        console.error(`updateStats (from ${source}) called with null/undefined statsDataFromBackend.`); 
        return; 
    }

    // Helper to safely update textContent of an element if it exists
    const setText = (id, value) => {
        const el = document.getElementById(id);
        if (el) {
            el.textContent = value;
        } else {
            // This log can be noisy if elements are intentionally absent for certain user types.
            // console.warn(`updateStats: Element with ID '${id}' not found (this may be normal).`);
        }
    };

    // --- Update elements common to both "Current Game" (for logged-in) and "Your Current Statistics" (for guests) ---
    // These IDs are now used for the "Current Game" section for logged-in users,
    // and also for the main stats for guests.
    setText('stat-total-score', (statsDataFromBackend.cumulative_score !== undefined ? parseFloat(statsDataFromBackend.cumulative_score).toFixed(1) : '0'));
    setText('stat-game-progress', statsDataFromBackend.questions_this_game !== undefined ? statsDataFromBackend.questions_this_game : '0');
    
    // game_length_setting might come from statsDataFromBackend (if from submit_answer/new_game) 
    // or directly from a template variable for guests if using get_setting in Jinja.
    // For simplicity, ensure it's in statsDataFromBackend if this function is to update it.
    // The Python 'new_stats' from submit_answer/new_game already includes game_length_setting.
    // For /get_stats (used by fetchStats for initial load), it also includes it.
    setText('stat-game-length', statsDataFromBackend.game_length_setting !== undefined ? statsDataFromBackend.game_length_setting : 'N/A');


    // --- Update elements specific to "Your Current Statistics" (for GUESTS) ---
    // These elements will only exist in the DOM if the guest stats block was rendered.
    // We can check for the existence of one of them.
    if (document.getElementById('stat-answered')) { 
        setText('stat-answered', statsDataFromBackend.total_answered !== undefined ? statsDataFromBackend.total_answered : '0');
        setText('stat-correct', statsDataFromBackend.total_correct !== undefined ? statsDataFromBackend.total_correct : '0');
        
        const accuracy = (statsDataFromBackend.total_answered && statsDataFromBackend.total_answered > 0 && statsDataFromBackend.total_correct !== undefined) 
                         ? ((statsDataFromBackend.total_correct / statsDataFromBackend.total_answered) * 100).toFixed(1) : 'N/A';
        setText('stat-accuracy', accuracy);

        const gameAvgBrier = (statsDataFromBackend.game_brier_scores && statsDataFromBackend.game_brier_scores.length > 0) 
                            ? (statsDataFromBackend.game_brier_scores.reduce((a, b) => a + b, 0) / statsDataFromBackend.game_brier_scores.length).toFixed(3) : 'N/A';
        setText('stat-game-avg-brier', gameAvgBrier);

        const sessionAvgBrier = (statsDataFromBackend.brier_scores && statsDataFromBackend.brier_scores.length > 0) 
                             ? (statsDataFromBackend.brier_scores.reduce((a, b) => a + b, 0) / statsDataFromBackend.brier_scores.length).toFixed(3) : 'N/A';
        setText('stat-session-avg-brier', sessionAvgBrier);
        
        setText('stat-games-played', statsDataFromBackend.games_played_session !== undefined ? statsDataFromBackend.games_played_session : '0');
    }

    // NOTE: The "Lifetime Statistics" (Overall and Category) for logged-in users are rendered
    // server-side by Jinja and are NOT updated by this client-side 'updateStats' function
    // after every question. They update on page load/refresh.
    // If you wanted them to update dynamically, 'updateStats' would need to make an AJAX call
    // to re-fetch lifetime stats, or the backend would need to send them with every submit_answer response.
}
function fetchStats() { fetch('/get_stats').then(r => r.json()).then(s => updateStats(s, "fetchStats_initial")).catch(e => console.error('Error fetching stats:', e)); }

function fetchCalibrationData() {
    let binsQueryParam = '';
    // chartBinsSelect should also be defined in a scope accessible here,
    // typically fetched once in DOMContentLoaded or globally if it always exists.
    // Assuming chartBinsSelect is already defined and accessible.
    if (chartBinsSelect && chartBinsSelect.value) {
        binsQueryParam = `?bins=${chartBinsSelect.value}`;
    }
    console.log(`fetchCalibrationData called. Query: /get_calibration_data${binsQueryParam}`);

    fetch(`/get_calibration_data${binsQueryParam}`)
        .then(r => {
            if (!r.ok) {
                // Try to get more specific error from backend if possible
                return r.json().then(err => { throw err; }).catch(() => {throw new Error(`HTTP error ${r.status}`)});
            }
            return r.json();
        })
        .then(data_from_server => { // Renamed 'd' for clarity
            console.log("Calibration data received from server:", data_from_server);
            
            // CRUCIAL: Update the global 'points' array here
            points = data_from_server.points || []; 
            
            renderCalibrationChart(data_from_server); // Pass the full data object
        })
        .catch(e => {
            console.error('Error fetching/rendering calibration data:', e);
            // Optionally, clear the chart or show an error message on the chart canvas
            // if (calibrationChart) {
            //     calibrationChart.clear(); 
            //     // Or display a message on the canvas
            // }
        });
}

// Assuming chartBinsSelect is fetched in DOMContentLoaded or is global
// const chartBinsSelect = document.getElementById('chart-bins-select'); // Should be defined before this
if (chartBinsSelect) {
    chartBinsSelect.addEventListener('change', function() {
        console.log(`Chart bins changed to: ${this.value}. Refetching calibration data.`);
        fetchCalibrationData(); // Re-fetch data when selection changes
    });
}

function renderCalibrationChart(data_for_chart) { // Parameter is the object from fetch: { points: [...] }
    // Use the points from the new data for chart rendering
    const new_dataset_points = data_for_chart.points || []; 
    
    // Prepare data specifically for Chart.js: extract x, y for the scatter plot
    const chartDataForScatter = new_dataset_points.map(p => ({ x: p.x, y: p.y }));
    
    // Calculate point radii based on the 'count' from the new_dataset_points
    const counts = new_dataset_points.map(p => p.count);
    const maxCount = Math.max(1, ...counts); // Avoid division by zero if all counts are 0
    const minRadius = 3;
    const maxRadius = 15;
    const pointRadii = new_dataset_points.map(p => {
        if (p.count <= 0) return minRadius;
        // Scale radius by square root of count for better visual area representation
        let radius = minRadius + (maxRadius - minRadius) * Math.sqrt(p.count / maxCount);
        return Math.min(radius, maxRadius); // Cap radius at maxRadius
    });

    const perfectLine = [{x: 0, y: 0.0}, {x: 100, y: 1.0}]; // Perfect calibration line data

    if (calibrationChart) { 
        // If chart instance already exists, update its data
        calibrationChart.data.datasets[0].data = chartDataForScatter; // Update scatter plot points
        calibrationChart.data.datasets[0].pointRadius = pointRadii;   // Update radii
        // You might want to update pointHoverRadius too if it's derived from pointRadii
        calibrationChart.data.datasets[0].pointHoverRadius = pointRadii.map(r => Math.min(r + 2, maxRadius + 2));

        calibrationChart.update(); // Tell Chart.js to re-render
        console.log("Calibration chart updated with new data.");
    } else { 
        // If chart instance doesn't exist, create it
        calibrationChart = new Chart(calibrationChartCtx, { // calibrationChartCtx must be your canvas context
            type: 'scatter', 
            data: { 
                datasets: [ 
                    { 
                        label: 'Calibration Bins', 
                        data: chartDataForScatter, // Use the x,y mapped data
                        backgroundColor: 'rgba(0, 0, 255, 0.7)', 
                        borderColor: 'rgba(0, 0, 255, 1)', 
                        pointRadius: pointRadii, 
                        pointHoverRadius: pointRadii.map(r => Math.min(r + 2, maxRadius + 2)), 
                        order: 2 // Ensure scatter points are drawn on top of the line if overlapping
                    }, 
                    { 
                        label: 'Perfect Calibration', 
                        data: perfectLine, 
                        type: 'line', // Render this dataset as a line
                        borderColor: 'rgba(200, 200, 200, 0.8)', 
                        borderWidth: 2, 
                        pointRadius: 0, // No points on the line itself
                        fill: false, 
                        tension: 0, // Straight line
                        order: 1 
                    } 
                ] 
            }, 
            options: { 
                scales: { 
                    x: { 
                        type: 'linear', 
                        position: 'bottom', 
                        title: { display: true, text: 'Average Confidence in Bin (%)' }, 
                        min: 0, 
                        max: 100 
                    }, 
                    y: { 
                        title: { display: true, text: 'Accuracy (Proportion Correct)' }, 
                        min: 0, 
                        max: 1.0 
                    } 
                }, 
                plugins: { 
                    tooltip: { 
                        callbacks: {
                            label: function(context) { // 'context' is the tooltip item
                                if (context.datasetIndex === 0) { // Tooltip for 'Calibration Bins' dataset
                                    const pointIndex = context.dataIndex; // Index of the point in the dataset
                                    
                                    // --- DEBUGGING LOGS ---
                                    const chartJSDatasetPoint = context.chart.data.datasets[0].data[pointIndex];
                                    // 'points' here refers to the GLOBAL 'points' array, which should have been
                                    // updated in fetchCalibrationData before this function was called.
                                    const originalPointFromGlobalArray = points[pointIndex]; 

                                    console.log(`Tooltip hover: pointIndex [${pointIndex}]`);
                                    console.log(`Global 'points' array length: ${points.length}`);
                                    console.log(`Global points[${pointIndex}]:`, originalPointFromGlobalArray);
                                    console.log(`Chart.js internal data point for this index (chartJSDatasetPoint):`, chartJSDatasetPoint);
                                    // --- END DEBUGGING LOGS ---

                                    if (!originalPointFromGlobalArray) {
                                        // If our global 'points' array doesn't have corresponding full data.
                                        if (chartJSDatasetPoint) {
                                            // Fallback to display basic x,y from Chart.js internal data if available
                                            return `Chart.js Point (Avg Conf: ${chartJSDatasetPoint.x.toFixed(1)}%, Acc: ${(chartJSDatasetPoint.y * 100).toFixed(1)}%) - Detailed info missing`;
                                        }
                                        return "Data point error (original data not found for tooltip)";
                                    }
                                    // Use originalPointFromGlobalArray which contains x, y, and count
                                    let label = `Bin Data: Avg Confidence: ${originalPointFromGlobalArray.x.toFixed(1)}%, Accuracy: ${(originalPointFromGlobalArray.y * 100).toFixed(1)}% (Count: ${originalPointFromGlobalArray.count})`;
                                    // The "Bin X:" part is harder to determine accurately here without knowing num_bins
                                    // and the exact bin ranges. So, focusing on the data itself.
                                    return label;
                                } else { // Tooltip for other datasets (e.g., "Perfect Calibration" line)
                                    return null; // Or use default Chart.js tooltip for these
                                } 
                            } 
                        } 
                    }, 
                    legend: { 
                        display: true 
                    } 
                }, 
                responsive: true, 
                maintainAspectRatio: true // Or false if you want to control size more directly via CSS
            } 
        });
        console.log("Calibration chart created.");
    }
}

newQuestionButton.addEventListener('click', () => {
    const buttonText = newQuestionButton.textContent;
    console.log(`newQuestionButton clicked. Text: "${buttonText}". Game in progress: ${isGameInProgress()}`);

    // Scenario: User is in pre-game options, might have changed category,
    // and clicks "Begin Game" while a previous game's state (currentQuestionData/lastAnswerFeedbackFromServer)
    // technically still exists (e.g. they navigated away and back).
    if (buttonText === 'Begin Game' && isGameInProgress()) {
        if (!window.confirm("You have an unfinished game. Starting a new one will abandon it and its score. Are you sure?")) {
            return; // User cancelled
        }
        // User confirmed. Reset game state, then fetch new question with current UI selections.
        startNewGame().then(() => {
            console.log("Game reset. Fetching new question for 'Begin Game' click.");
            fetchNewQuestion(); // Uses category selections from UI
        }).catch(err => console.error("Error in startNewGame from Begin Game (mid-game):", err));
        return; // Important to stop further execution
    }

    // Standard flow for "Get Next Question" or "Play Again?"
    // Also handles "Begin Game" when no game is in progress.
    if (lastAnswerFeedbackFromServer) { 
        fetch('/clear_last_feedback', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if(data.status === 'success') console.log("Feedback cleared by newQuestionButton.");
                lastAnswerFeedbackFromServer = null; 
                proceedWithActualButtonAction(buttonText); // Pass the original buttonText
            })
            .catch(err => {
                console.error("Error clearing feedback, proceeding anyway:", err);
                lastAnswerFeedbackFromServer = null;
                proceedWithActualButtonAction(buttonText); // Pass the original buttonText
            });
    } else {
        proceedWithActualButtonAction(buttonText); // Pass the original buttonText
    }
});

// proceedWithActualButtonAction function (mostly as before, ensure it uses showPreGameOptions)
function proceedWithActualButtonAction(buttonText) {
    if (buttonText === 'Play Again?') {
        startNewGame().then(() => {
             // No need to handle pendingCat from sessionStorage here, as "Play Again"
             // doesn't imply a specific new category was chosen via a "Play This" button.
             // showPreGameOptions() is called within startNewGame().then() already.
        }).catch(err => console.error("Error in startNewGame from Play Again (proceed):", err));
    } else { // "Begin Game" (no game in progress) or "Get Next Question"
        fetchNewQuestion(); 
    }
}

    submitButton.addEventListener('click', submitAnswer);
    confidenceSlider.addEventListener('input', (e) => { confidenceValueElement.textContent = `${e.target.value}%`; });

    function proceedWithNewQuestionButtonAction() {
        // This function is called AFTER feedback is cleared (if any) by newQuestionButton handler
        if (newQuestionButton.textContent === 'Play Again?') {
            // 'Play Again?' implies end_of_game was true.
            // startNewGame will reset server session for game, then UI.
            startNewGame().then(() => {
                showPreGameOptions(); // Ensure UI is in pre-game state after successful new game start
                // Check if a category was pending from a "Play This Category" click that triggered Play Again
                const pendingCatType = sessionStorage.getItem('pending_category_type');
                const pendingCatValue = sessionStorage.getItem('pending_category_value');
                if (pendingCatType && pendingCatValue) {
                    sessionStorage.removeItem('pending_category_type');
                    sessionStorage.removeItem('pending_category_value');
                    console.log("Applying pending category after 'Play Again?' led to new game:", pendingCatType, pendingCatValue);
                    setCategoryAndBegin(pendingCatType, pendingCatValue); // This will then click "Begin Game"
                }
            }).catch(err => console.error("Error in startNewGame from Play Again:", err));
        } else { // "Begin Game" or "Get Next Question"
            fetchNewQuestion(); // This will fetch based on current UI selections
        }
    }

// Wrapper for clarity when starting a new game AND immediately fetching a question
function startNewGameAndFetch() {
    // startNewGame() should reset UI to show pre-game options if successful.
    // It also makes a call to /start_new_game which resets server session.
    // After it completes, fetchNewQuestion() can be called.
    // This might need a Promise or callback if startNewGame() is async and doesn't reload.
    // Assuming startNewGame is synchronous in its UI reset or reloads the page:
    
    // If startNewGame reloads page, the new category from UI will be used.
    // If startNewGame is AJAX and updates UI, then call fetchNewQuestion after its success.
    
    // Let's refine startNewGame to return a promise for better chaining.
    // For now, a simple sequence (might have timing issues if startNewGame is slow AJAX w/o reload):
    startNewGame(); // This should reset game state and UI to show pre-game options
    setTimeout(() => { // Give a moment for UI reset from startNewGame if it's not instant
        fetchNewQuestion(); // This will use the currently selected categories
    }, 100); 
}


// Modified setCategoryAndBegin function
function setCategoryAndBegin(catType, catValue) {
    console.log(`setCategoryAndBegin called for: Type=${catType}, Value=${catValue}. Game in progress: ${isGameInProgress()}`);

    if (isGameInProgress()) {
        if (!window.confirm("You have a game in progress. Starting a new game in this category will abandon your current one and its score. Are you sure?")) {
            console.log("User cancelled starting new category game.");
            return; // User cancelled
        }
        
        // User confirmed to abandon current game.
        console.log("User confirmed. Resetting current game via startNewGame().");
        startNewGame().then(() => {
            console.log("Game reset by startNewGame(). Now setting new category and fetching question.");
            // UI should now be in pre-game state.
            window.scrollTo(0, 0);
            setCategoryValuesInUI(catType, catValue); // Set dropdowns/inputs
            if (newQuestionButton && newQuestionButton.textContent === 'Begin Game') {
                newQuestionButton.click(); // Start the new game with the chosen category
            } else {
                console.warn("setCategoryAndBegin after reset: 'Begin Game' button not ready. Attempting fetchNewQuestion directly.");
                fetchNewQuestion(); // Fallback
            }
        }).catch(err => {
            console.error("Error during startNewGame sequence in setCategoryAndBegin:", err);
            showPreGameOptions(); // Ensure UI is in a safe state
        });
        return; // Exit after initiating the reset and new game sequence
    }

    // No game was in progress, or it has just been reset by the block above.
    console.log("No game in progress or game was reset. Proceeding to set category and start.");
    window.scrollTo(0, 0); 
    showPreGameOptions(); // Ensure UI is in pre-game state
    setCategoryValuesInUI(catType, catValue);
    
    if (newQuestionButton && newQuestionButton.textContent === 'Begin Game') {
        // Using a minimal timeout to ensure DOM updates from setCategoryValuesInUI are processed
        // before the click event is dispatched.
        setTimeout(() => { newQuestionButton.click(); }, 50);
    } else {
        console.warn("setCategoryAndBegin: newQuestionButton not in 'Begin Game' state for direct start.");
         setTimeout(() => { fetchNewQuestion(); }, 50); // Fallback
    }
}

// Helper to set UI elements (no change from before)
function setCategoryValuesInUI(catType, catValue) {
    if (catType === 'user_category_custom') {
        if (customCategoryInput) customCategoryInput.value = catValue;
        if (prefabCategorySelect) prefabCategorySelect.value = 'random'; 
    } else { // user_category_prefab
        if (prefabCategorySelect) prefabCategorySelect.value = catValue;
        if (customCategoryInput) customCategoryInput.value = ''; 
    }
}

document.addEventListener('DOMContentLoaded', () => {
    console.log("DOMContentLoaded: Fired");

    // --- 1. Initialize DOM Element References (if not already global) ---
    // Assuming these are defined globally or at the top of your <script> tag:
    // const userNicknameTextElement = document.getElementById('user-nickname-text');
    // const completeRegistrationPrompt = document.getElementById('complete-registration-prompt');
    // const preGameOptionsDiv = document.getElementById('pre-game-options');
    // const newQuestionButton = document.getElementById('new-question-button');
    // const gameArea = document.getElementById('game-area');
    // const chartBinsSelect = document.getElementById('chart-bins-select');
    // const categoryStatsTable = document.getElementById('categoryStatsTable'); // For sortable table
    // ... and any others needed by helper functions like handleNicknameSetup, renderQuestion, etc.

    // --- 2. Parse Initial State from Server-Rendered Template ---
    let userInfoOnLoad = null;
    try { userInfoOnLoad = JSON.parse('{{ user_info | tojson | safe if user_info is not none else "null" }}'); } 
    catch (e) { console.error("Error parsing user_info:", e); }

    let activeQuestionDataFromServer = null;
    try { activeQuestionDataFromServer = JSON.parse('{{ active_question_data | tojson | safe if active_question_data is not none else "null" }}'); } 
    catch (e) { console.error("Error parsing active_question_data:", e); }
    
    let lastAnswerFeedbackDataFromTemplate = null; 
    try { 
        lastAnswerFeedbackDataFromTemplate = JSON.parse('{{ last_answer_feedback_data | tojson | safe if last_answer_feedback_data is not none else "null" }}');
    } catch (e) { console.error("Error parsing last_answer_feedback_data:", e); }

    let needsNicknameSetupOnLoad = ('{{ needs_nickname_setup | default(false) | tojson }}' === 'true');
    let suggestedNicknameOnLoad = null;
    try { suggestedNicknameOnLoad = JSON.parse('{{ suggested_nickname | tojson | safe if suggested_nickname is not none else "null" }}'); } 
    catch (e) { console.error("Error parsing suggested_nickname:", e); }

    // Update global JS state variables
    currentQuestionData = activeQuestionDataFromServer; // Initialize global
    lastAnswerFeedbackFromServer = lastAnswerFeedbackDataFromTemplate; // Initialize global

    if (sessionStorage.getItem('force_nickname_setup') === 'true') {
        needsNicknameSetupOnLoad = true;
        const storedSuggestion = sessionStorage.getItem('suggested_nickname_temp');
        if (storedSuggestion) suggestedNicknameOnLoad = storedSuggestion; 
        sessionStorage.removeItem('force_nickname_setup');
        sessionStorage.removeItem('suggested_nickname_temp');
        console.log("DOMContentLoaded: Forced nickname setup.");
    }

    // --- 3. Initial User Info and Prompt Display ---
    let currentConfirmedNicknameForDisplay = "Guest";
    if (userInfoOnLoad && userInfoOnLoad.nickname) {
        currentConfirmedNicknameForDisplay = userInfoOnLoad.nickname;
        if (userNicknameTextElement) userNicknameTextElement.textContent = currentConfirmedNicknameForDisplay;

        if (completeRegistrationPrompt) {
            if (userInfoOnLoad.user_id && !userInfoOnLoad.email_registered) {
                let promptNickname = userInfoOnLoad.nickname || "User"; 
                completeRegistrationPrompt.innerHTML = `Welcome, <strong>${promptNickname}</strong>! <a href="{{ url_for('register') }}">Complete your registration</a>...`;
                completeRegistrationPrompt.classList.remove('hidden');
            } else {
                completeRegistrationPrompt.classList.add('hidden');
            }
        }
    } else if (completeRegistrationPrompt) { 
        completeRegistrationPrompt.classList.add('hidden');
    }
    
    // --- 4. Nickname Setup UI ---
    handleNicknameSetup(needsNicknameSetupOnLoad, suggestedNicknameOnLoad, currentConfirmedNicknameForDisplay);
    
    // --- 5. Fetch Dynamic Categories ---
    fetchUserCategories(); 
    
    // --- 6. Determine Auto-Start Category (from URL first, then sessionStorage) ---
    const urlParams = new URLSearchParams(window.location.search);
    let autoStartCatType = null;
    let autoStartCatValue = null;
    let sourceOfAutoStart = null; // For logging

    if (urlParams.has('user_category_custom')) {
        autoStartCatType = 'user_category_custom';
        autoStartCatValue = urlParams.get('user_category_custom');
        sourceOfAutoStart = 'URL';
    } else if (urlParams.has('user_category_prefab')) {
        autoStartCatType = 'user_category_prefab';
        autoStartCatValue = urlParams.get('user_category_prefab');
        sourceOfAutoStart = 'URL';
    } else { 
        autoStartCatType = sessionStorage.getItem('pending_category_type');
        autoStartCatValue = sessionStorage.getItem('pending_category_value');
        if (autoStartCatType && autoStartCatValue) {
            sourceOfAutoStart = 'sessionStorage';
        }
    }

    // --- 7. Initial Game Area UI Setup OR Auto-Start Game ---
    // This section decides what to show initially if no auto-start,
    // or prepares for auto-start by calling setCategoryAndBegin.

    if (autoStartCatType && autoStartCatValue) { // If an auto-start category is determined
        console.log(`DOMContentLoaded: Auto-starting category from ${sourceOfAutoStart} - Type: ${autoStartCatType}, Value: ${autoStartCatValue}`);
        
        if (sourceOfAutoStart === 'sessionStorage') { // Clear sessionStorage if it was the source
            sessionStorage.removeItem('pending_category_type');
            sessionStorage.removeItem('pending_category_value');
        }
        if (sourceOfAutoStart === 'URL' && window.history.replaceState) { // Clear URL params if they were the source
            const cleanURL = window.location.protocol + "//" + window.location.host + window.location.pathname;
            window.history.replaceState({path: cleanURL}, '', cleanURL);
        }
        
        // Delay slightly to ensure handleNicknameSetup (if run) has finished UI changes
        setTimeout(() => {
            console.log("DOMContentLoaded: Calling setCategoryAndBegin for auto-start.");
            setCategoryAndBegin(autoStartCatType, autoStartCatValue);
        }, 100); // Reduced delay a bit, adjust if needed
    } else {
        // NO auto-start category. Set up UI based on current state (feedback, active Q, or pre-game).
        if (needsNicknameSetupOnLoad) {
            if(gameArea) gameArea.classList.add('hidden'); 
        } else if (lastAnswerFeedbackFromServer) {
            console.log("DOMContentLoaded: No auto-start. Displaying initial feedback.");
            displayAnswerFeedback(lastAnswerFeedbackFromServer);
            if(gameArea) gameArea.classList.remove('hidden');
        } else if (currentQuestionData) { 
            console.log("DOMContentLoaded: No auto-start. Displaying initial active question.");
            renderQuestion(currentQuestionData);
            if(gameArea) gameArea.classList.remove('hidden');
        } else if (!needsNicknameSetupOnLoad) { 
            console.log("DOMContentLoaded: No auto-start. Showing pre-game options.");
            showPreGameOptions();
            if(gameArea) gameArea.classList.remove('hidden');
        }
    }

    // --- 8. Chart Bin Controls & Initial Data Fetches ---
    const defaultChartBinsFromServer = parseInt('{{ default_chart_bins | default(10) }}', 10);
    // const chartBinsSelect = document.getElementById('chart-bins-select'); // Assumed defined globally or top of script

    if (chartBinsSelect) {
        chartBinsSelect.value = defaultChartBinsFromServer.toString();
        chartBinsSelect.addEventListener('change', fetchCalibrationData); // Simplified listener
    }
    
    fetchStats(); 
    fetchCalibrationData(); 

    // --- 9. Initialize Table Sorter (Your existing sortable table JS) ---
    // const categoryTable = document.getElementById('categoryStatsTable');
    if (categoryStatsTable) { // Make sure categoryStatsTable is defined
        // ... (your full table sorting logic from the previous working version) ...
        // Ensure 'headers', 'currentSort', 'sortTable' are defined within this if block
        // or in a scope accessible if they are helper functions.
    }

    // --- 10. Event Delegation for "Play This Category" (Your existing listener) ---
    // This should be attached to a static parent if the table is dynamic, or directly if table always exists.
    // document.body.addEventListener('click', function(event) { ... }); // This is generally fine.
    // Your existing event listener for 'play-category-button' should be here.

    console.log("DOMContentLoaded: All setup complete.");
});

    function setCategoryAndBegin(catType, catValue) {
        console.log("setCategoryAndBegin called with:", catType, catValue, "isGameInProgress:", isGameInProgress());
        if (isGameInProgress()) {
            if (!window.confirm("You have a game in progress. Starting a new game in this category will abandon your current one and its score. Are you sure?")) {
                return; // User cancelled
            }
            // User confirmed. Store pending category and start a new game.
            // startNewGame() will reset server and client state.
            // After startNewGame() completes, it should result in the pre-game UI.
            // The DOMContentLoaded (if page reloads) or logic after startNewGame().then()
            // needs to pick up the pending category.
            sessionStorage.setItem('pending_category_type', catType);
            sessionStorage.setItem('pending_category_value', catValue);
            
            startNewGame().then(() => {
                // startNewGame has reset things and UI should be pre-game.
                // Now, apply the pending category.
                const pCatType = sessionStorage.getItem('pending_category_type');
                const pCatValue = sessionStorage.getItem('pending_category_value');
                if (pCatType && pCatValue) {
                    sessionStorage.removeItem('pending_category_type');
                    sessionStorage.removeItem('pending_category_value');
                    console.log("Applying pending category after confirmed new game start:", pCatType, pCatValue);
                    // Call setCategoryAndBegin again, but this time isGameInProgress will be false.
                    // This recursive call needs to be safe.
                    setCategoryAndBegin(pCatType, pCatValue); 
                } else {
                    // Should not happen if sessionStorage was set, but as fallback:
                    showPreGameOptions();
                }
            }).catch(err => {
                console.error("Error during startNewGame in setCategoryAndBegin:", err);
                showPreGameOptions(); // Show pre-game options on error
            });
            return; 
        }

        // No game in progress, or user confirmed abandoning old one.
        window.scrollTo(0, 0); 
        showPreGameOptions(); // Ensure pre-game options and "Begin Game" button are visible and correctly set.
        
        if (catType === 'user_category_custom') {
            if (customCategoryInput) customCategoryInput.value = catValue;
            if (prefabCategorySelect) prefabCategorySelect.value = 'random'; 
        } else { // user_category_prefab
            if (prefabCategorySelect) prefabCategorySelect.value = catValue;
            if (customCategoryInput) customCategoryInput.value = ''; 
        }
        
        console.log("Category set in UI, attempting to click 'Begin Game' button.");
        if (newQuestionButton && newQuestionButton.textContent === 'Begin Game') {
            // Small delay can help ensure UI updates from setting select value are processed.
            setTimeout(() => { newQuestionButton.click(); }, 50);
        } else {
            console.warn("'Begin Game' button not found or text is not 'Begin Game'. Current text:", newQuestionButton ? newQuestionButton.textContent : "Button not found");
            // Fallback or error handling if button state is unexpected
            // Potentially directly call fetchNewQuestion after a small delay if button state is complex to manage here.
            setTimeout(() => { fetchNewQuestion(); }, 100);
        }
    }


</script>
{% endblock %}